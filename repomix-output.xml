This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
index.html
package.json
public/vite.svg
README.md
src/App.jsx
src/assets/react.svg
src/components/Character.jsx
src/components/CharacterController.jsx
src/components/Crab_2.jsx
src/components/Experience.jsx
src/components/Map.jsx
src/components/ProceduralIsland.jsx
src/components/Vegetation.jsx
src/index.css
src/main.jsx
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "r3f-vite-starter",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@react-three/drei": "9.75.0",
    "@react-three/fiber": "8.13.3",
    "@react-three/rapier": "^1.5.0",
    "@types/three": "0.152.1",
    "alea": "^1.0.1",
    "leva": "^0.9.35",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "simplex-noise": "^4.0.3",
    "three": "0.153.0"
  },
  "devDependencies": {
    "@types/react": "^18.0.27",
    "@types/react-dom": "^18.0.10",
    "@vitejs/plugin-react": "^3.1.0",
    "vite": "^4.1.0"
  }
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="README.md">
# r3f-3rd-person-controller-starter

![Video thumbnail](http://img.youtube.com/vi/yjpGVIe_Gy8/maxresdefault.jpg?w)

[Video tutorial](https://youtu.be/yjpGVIe_Gy8)

[Final code](https://github.com/wass08/r3f-3rd-person-controller-final)
[Live demo](https://r3f-3rd-person-controller-final.vercel.app/)

```
yarn
yarn dev
```

## 3D Models Credits
https://sketchfab.com/3d-models/castle-on-hills-b874cb19b42741729b950f6afbdf0dea

https://sketchfab.com/3d-models/de-dust-2-with-real-light-4ce74cd95c584ce9b12b5ed9dc418db5

https://sketchfab.com/3d-models/animal-crossing-map-9f53cb8a02134037887875e022b2eae2

https://sketchfab.com/3d-models/medieval-fantasy-book-06d5a80a04fc4c5ab552759e9a97d91a

https://sketchfab.com/3d-models/city-scene-tokyo-b25d23ff186949dca3df669c14447db5
</file>

<file path="src/App.jsx">
import { Canvas } from "@react-three/fiber";
import { Experience } from "./components/Experience";
import { KeyboardControls } from "@react-three/drei";

const keyboardMap = [
  { name: "forward", keys: ["ArrowUp", "KeyW"] },
  { name: "backward", keys: ["ArrowDown", "KeyS"] },
  { name: "left", keys: ["ArrowLeft", "KeyA"] },
  { name: "right", keys: ["ArrowRight", "KeyD"] },
  { name: "run", keys: ["Shift"] },
];

function App() {
  return (
    <KeyboardControls map={keyboardMap}>
      <Canvas
        shadows
        camera={{ position: [3, 3, 3], near: 0.1, fov: 40 }}
        style={{
          touchAction: "none",
        }}
      >
        <color attach="background" args={["#ececec"]} />
        <Experience />
      </Canvas>
    </KeyboardControls>
  );
}

export default App;
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/components/Character.jsx">
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 public/models/character.glb -o src/components/Character.jsx -r public
*/

import { useAnimations, useGLTF } from "@react-three/drei";
import React, { useEffect, useRef } from "react";

export function Character({ animation, ...props }) {
  const group = useRef();
  const { nodes, materials, animations } = useGLTF("/models/character.glb");
  const { actions } = useAnimations(animations, group);
  useEffect(() => {
    actions[animation]?.reset().fadeIn(0.24).play();
    return () => actions?.[animation]?.fadeOut(0.24);
  }, [animation]);
  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="fall_guys">
          <primitive object={nodes._rootJoint} />
          <skinnedMesh
            name="body"
            geometry={nodes.body.geometry}
            material={materials.Material}
            skeleton={nodes.body.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="eye"
            geometry={nodes.eye.geometry}
            material={materials.Material}
            skeleton={nodes.eye.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="hand-"
            geometry={nodes["hand-"].geometry}
            material={materials.Material}
            skeleton={nodes["hand-"].skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="leg"
            geometry={nodes.leg.geometry}
            material={materials.Material}
            skeleton={nodes.leg.skeleton}
            castShadow
            receiveShadow
          />
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/models/character.glb");
</file>

<file path="src/components/CharacterController.jsx">
import { useKeyboardControls } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { CapsuleCollider, RigidBody } from "@react-three/rapier";
import { useControls } from "leva";
import { useEffect, useRef, useState } from "react";
import { MathUtils, Vector3 } from "three";
import { degToRad } from "three/src/math/MathUtils.js";
import { Character } from "./Character";
import { Crab_2 } from "./Crab_2";

const normalizeAngle = (angle) => {
  while (angle > Math.PI) angle -= 2 * Math.PI;
  while (angle < -Math.PI) angle += 2 * Math.PI;
  return angle;
};

const lerpAngle = (start, end, t) => {
  start = normalizeAngle(start);
  end = normalizeAngle(end);

  if (Math.abs(end - start) > Math.PI) {
    if (end > start) {
      start += 2 * Math.PI;
    } else {
      end += 2 * Math.PI;
    }
  }

  return normalizeAngle(start + (end - start) * t);
};

export const CharacterController = () => {
  const { WALK_SPEED, RUN_SPEED, ROTATION_SPEED } = useControls(
    "Character Control",
    {
      WALK_SPEED: { value: 0.8, min: 0.1, max: 4, step: 0.1 },
      RUN_SPEED: { value: 1.6, min: 0.2, max: 12, step: 0.1 },
      ROTATION_SPEED: {
        value: degToRad(0.5),
        min: degToRad(0.1),
        max: degToRad(5),
        step: degToRad(0.1),
      },
    }
  );
  const rb = useRef();
  const container = useRef();
  const character = useRef();

  const [animation, setAnimation] = useState("idle");

  const characterRotationTarget = useRef(0);
  const rotationTarget = useRef(0);
  const cameraTarget = useRef();
  const cameraPosition = useRef();
  const cameraWorldPosition = useRef(new Vector3());
  const cameraLookAtWorldPosition = useRef(new Vector3());
  const cameraLookAt = useRef(new Vector3());
  const [, get] = useKeyboardControls();
  const isClicking = useRef(false);

  useEffect(() => {
    const onMouseDown = (e) => {
      isClicking.current = true;
    };
    const onMouseUp = (e) => {
      isClicking.current = false;
    };
    document.addEventListener("mousedown", onMouseDown);
    document.addEventListener("mouseup", onMouseUp);
    // touch
    document.addEventListener("touchstart", onMouseDown);
    document.addEventListener("touchend", onMouseUp);
    return () => {
      document.removeEventListener("mousedown", onMouseDown);
      document.removeEventListener("mouseup", onMouseUp);
      document.removeEventListener("touchstart", onMouseDown);
      document.removeEventListener("touchend", onMouseUp);
    };
  }, []);

  useFrame(({ camera, mouse }) => {
    if (rb.current) {
      const vel = rb.current.linvel();

      const movement = {
        x: 0,
        z: 0,
      };

      if (get().forward) {
        movement.z = 1;
      }
      if (get().backward) {
        movement.z = -1;
      }

      let speed = get().run ? RUN_SPEED : WALK_SPEED;

      if (isClicking.current) {
        if (Math.abs(mouse.x) > 0.1) {
          movement.x = -mouse.x;
        }
        movement.z = mouse.y + 0.4;
        if (Math.abs(movement.x) > 0.5 || Math.abs(movement.z) > 0.5) {
          speed = RUN_SPEED;
        }
      }

      if (get().left) {
        movement.x = 1;
      }
      if (get().right) {
        movement.x = -1;
      }

      if (movement.x !== 0) {
        rotationTarget.current += ROTATION_SPEED * movement.x;
      }

      if (movement.x !== 0 || movement.z !== 0) {
        characterRotationTarget.current = Math.atan2(movement.x, movement.z);
        vel.x =
          Math.sin(rotationTarget.current + characterRotationTarget.current) *
          speed;
        vel.z =
          Math.cos(rotationTarget.current + characterRotationTarget.current) *
          speed;
        if (speed === RUN_SPEED) {
          // setAnimation("run");
          setAnimation("WalkSide");
        } else {
          // setAnimation("walk");
          setAnimation("WalkFace");
        }
      } else {
        // setAnimation("idle");
        setAnimation("Hiddle");
      }
      character.current.rotation.y = lerpAngle(
        character.current.rotation.y,
        characterRotationTarget.current,
        0.1
      );

      rb.current.setLinvel(vel, true);
    }

    // CAMERA
    container.current.rotation.y = MathUtils.lerp(
      container.current.rotation.y,
      rotationTarget.current,
      0.1
    );

    cameraPosition.current.getWorldPosition(cameraWorldPosition.current);
    camera.position.lerp(cameraWorldPosition.current, 0.1);

    if (cameraTarget.current) {
      cameraTarget.current.getWorldPosition(cameraLookAtWorldPosition.current);
      cameraLookAt.current.lerp(cameraLookAtWorldPosition.current, 0.1);

      camera.lookAt(cameraLookAt.current);
    }
  });

  return (
    <RigidBody colliders={false} lockRotations ref={rb}>
      <group ref={container}>
        <group ref={cameraTarget} position-z={1.5} />
        <group ref={cameraPosition} position-y={4} position-z={-4} />
        <group ref={character}>
          {/* <Character scale={0.18} position-y={-0.25} animation={animation} /> */}
          <Crab_2 scale={0.18} position-y={-0.25} animation={animation} />
        </group>
      </group>
      <CapsuleCollider args={[0.08, 0.15]} />
    </RigidBody>
  );
};
</file>

<file path="src/components/Crab_2.jsx">
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 Crab_2.glb --transform 
Files: Crab_2.glb [3.14MB] > C:\Users\pegaz\Downloads\Crab_2-transformed.glb [2.02MB] (35%)
*/

import React, { useEffect, useRef } from "react";
import { useGraph } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";

export function Crab_2({ animation, ...props }) {
  const group = React.useRef();
  const { scene, animations } = useGLTF("/models/Crab_2.glb");
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);
  const { actions } = useAnimations(animations, group);
  useEffect(() => {
    actions[animation]?.reset().fadeIn(0.24).play();
    return () => actions?.[animation]?.fadeOut(0.24);
  }, [animation]);
  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="Crab_rig001" rotation={[0, 0, 0]}>
          <primitive object={nodes.c_pos} />
          <primitive object={nodes.root_refx} />
          <primitive object={nodes.c_foot_ikl} />
          <primitive object={nodes.c_leg_polel} />
          <primitive object={nodes.c_foot_ikr} />
          <primitive object={nodes.c_leg_poler} />
          <primitive object={nodes.c_foot_ik_dupli_001l} />
          <primitive object={nodes.c_leg_pole_dupli_001l} />
          <primitive object={nodes.c_foot_ik_dupli_001r} />
          <primitive object={nodes.c_leg_pole_dupli_001r} />
          <primitive object={nodes.c_foot_ik_dupli_002l} />
          <primitive object={nodes.c_leg_pole_dupli_002l} />
          <primitive object={nodes.c_foot_ik_dupli_002r} />
          <primitive object={nodes.c_leg_pole_dupli_002r} />
          <primitive object={nodes.c_arms_polel} />
          <primitive object={nodes.c_hand_ikl} />
          <primitive object={nodes.c_arms_poler} />
          <primitive object={nodes.c_hand_ikr} />
        </group>
        <skinnedMesh
          name="Crab_geo001"
          geometry={nodes.Crab_geo001.geometry}
          material={nodes.Crab_geo001.material}
          skeleton={nodes.Crab_geo001.skeleton}
          rotation={[0, -Math.PI / 2, 0]}
        />
        <skinnedMesh
          name="Cube"
          geometry={nodes.Cube.geometry}
          material={nodes.Cube.material}
          skeleton={nodes.Cube.skeleton}
          rotation={[0, -Math.PI / 2, 0]}
        />
        <skinnedMesh
          name="Cube001"
          geometry={nodes.Cube001.geometry}
          material={nodes.Cube001.material}
          skeleton={nodes.Cube001.skeleton}
          morphTargetDictionary={nodes.Cube001.morphTargetDictionary}
          morphTargetInfluences={nodes.Cube001.morphTargetInfluences}
          rotation={[0, -Math.PI / 2, 0]}
        />
        <skinnedMesh
          name="Cube002"
          geometry={nodes.Cube002.geometry}
          material={nodes.Cube002.material}
          skeleton={nodes.Cube002.skeleton}
          morphTargetDictionary={nodes.Cube002.morphTargetDictionary}
          morphTargetInfluences={nodes.Cube002.morphTargetInfluences}
          rotation={[0, -Math.PI / 2, 0]}
        />
        <skinnedMesh
          name="Cube003"
          geometry={nodes.Cube003.geometry}
          material={nodes.Cube003.material}
          skeleton={nodes.Cube003.skeleton}
          morphTargetDictionary={nodes.Cube003.morphTargetDictionary}
          morphTargetInfluences={nodes.Cube003.morphTargetInfluences}
          rotation={[0, -Math.PI / 2, 0]}
        />
      </group>
    </group>
  );
}

useGLTF.preload("/models/Crab_2.glb");
</file>

<file path="src/components/Experience.jsx">
import {
  Environment,
  OrbitControls,
  OrthographicCamera,
} from "@react-three/drei";
import { useControls } from "leva";
import { useRef } from "react";
import { Character } from "./Character";
import { Map } from "./Map";
import { Physics } from "@react-three/rapier";
import { CharacterController } from "./CharacterController";
import { ProceduralIsland } from "./ProceduralIsland";

const maps = {
  procedural_island: {
    isCustom: true, // Indique que c'est un terrain personnalisé et non un modèle GLB
    position: [0, -4, 0],
  },
  castle_on_hills: {
    scale: 3,
    position: [-6, -7, 0],
  },
  animal_crossing_map: {
    scale: 20,
    position: [-15, -1, 10],
  },
  city_scene_tokyo: {
    scale: 0.72,
    position: [0, -1, -3.5],
  },
  de_dust_2_with_real_light: {
    scale: 0.3,
    position: [-5, -3, 13],
  },
  medieval_fantasy_book: {
    scale: 0.4,
    position: [-4, 0, -6],
  },
};

export const Experience = () => {
  const shadowCameraRef = useRef();
  const { map } = useControls("Map", {
    map: {
      value: "procedural_island", // Par défaut, utilise l'île procédurale
      options: Object.keys(maps),
    },
  });
  const { debugPhysics } = useControls("Physics", {
    debugPhysics: true,
  });

  // Ajustements pour l'éclairage avec l'île
  const lightSettings =
    map === "procedural_island"
      ? { position: [-20, 30, 20], intensity: 1.2 }
      : { position: [-15, 10, 15], intensity: 0.65 };

  return (
    <>
      {/* <OrbitControls /> */}
      <Environment preset="sunset" />
      <directionalLight
        intensity={lightSettings.intensity}
        castShadow
        position={lightSettings.position}
        shadow-mapSize-width={2048}
        shadow-mapSize-height={2048}
        shadow-bias={-0.00005}
      >
        <OrthographicCamera
          left={-22}
          right={15}
          top={10}
          bottom={-20}
          ref={shadowCameraRef}
          attach={"shadow-camera"}
        />
      </directionalLight>
      <Physics key={map} debug={debugPhysics}>
        {map === "procedural_island" ? (
          // Rendu de l'île procédurale
          <ProceduralIsland position={maps[map].position} />
        ) : (
          // Rendu des modèles 3D existants
          <Map
            scale={maps[map].scale}
            position={maps[map].position}
            model={`models/${map}.glb`}
          />
        )}
        <CharacterController />
      </Physics>
    </>
  );
};
</file>

<file path="src/components/Map.jsx">
import { useAnimations, useGLTF } from "@react-three/drei";
import { RigidBody } from "@react-three/rapier";
import { useEffect, useRef } from "react";

export const Map = ({ model, ...props }) => {
  const { scene, animations } = useGLTF(model);
  const group = useRef();
  const { actions } = useAnimations(animations, group);
  useEffect(() => {
    scene.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
      }
    });
  }, [scene]);

  useEffect(() => {
    if (actions && animations.length > 0) {
      actions[animations[0].name].play();
    }
  }, [actions]);

  return (
    <group>
      <RigidBody type="fixed" colliders="trimesh">
        <primitive object={scene} {...props} ref={group} />
      </RigidBody>
    </group>
  );
};
</file>

<file path="src/components/ProceduralIsland.jsx">
import React, { useMemo, useRef, useState, useEffect } from "react";
import { useFrame } from "@react-three/fiber";
import { RigidBody } from "@react-three/rapier";
import { useControls } from "leva";
import * as THREE from "three";
import { createNoise2D } from "simplex-noise";
import alea from "alea";
import { Vegetation } from "./Vegetation";

export const ProceduralIsland = ({ ...props }) => {
  const meshRef = useRef();
  const waterRef = useRef();

  // Controls for island generation
  const {
    size,
    resolution,
    height,
    smoothing,
    waterLevel,
    seed,
    beachThreshold,
    mountainThreshold,
    beachColor,
    grassColor,
    mountainColor,
    enableVegetation,
    vegetationDensity,
  } = useControls("Island Generator", {
    size: { value: 100, min: 50, max: 300, step: 10 },
    resolution: { value: 128, min: 32, max: 256, step: 8 },
    height: { value: 2, min: 0.1, max: 10, step: 1 },
    smoothing: { value: 0.12, min: 0.01, max: 0.5, step: 0.01 },
    waterLevel: { value: 0.1, min: 0, max: 1, step: 0.01 },
    seed: { value: 42, min: 1, max: 100, step: 1 },
    beachThreshold: { value: 0.15, min: 0, max: 1, step: 0.01 },
    mountainThreshold: { value: 0.6, min: 0, max: 1, step: 0.01 },
    beachColor: "#e0c080",
    grassColor: "#3a9d23",
    mountainColor: "#706f6f",
    enableVegetation: true,
    vegetationDensity: { value: 50, min: 0, max: 200, step: 5 },
  });

  // State pour stocker la heightmap pour la réutiliser avec la végétation
  const [heightmapData, setHeightmapData] = useState(null);

  // Generate heightmap using Simplex noise
  const generateHeightmap = (
    width,
    height,
    scale,
    octaves,
    persistence,
    seed
  ) => {
    const noise2D = createNoise2D(alea(seed));
    const data = new Float32Array(width * height);

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        // Normalize coordinates to [-1, 1]
        const nx = (x / width - 0.5) * 2;
        const ny = (y / height - 0.5) * 2;

        // Calculate distance from center for island shape
        const distance = Math.sqrt(nx * nx + ny * ny);

        // Island mask - decreases height as we move away from center
        const islandMask = Math.max(0, 1 - distance);

        // Generate fractal Brownian motion (multiple octaves of noise)
        let elevation = 0;
        let amplitude = 1;
        let frequency = scale;
        let maxAmplitude = 0;

        for (let i = 0; i < octaves; i++) {
          const sampleX = (x * frequency) / width;
          const sampleY = (y * frequency) / height;

          elevation += noise2D(sampleX, sampleY) * amplitude;

          maxAmplitude += amplitude;
          amplitude *= persistence;
          frequency *= 2;
        }

        // Normalize elevation
        elevation /= maxAmplitude;

        // Apply island mask for circular falloff
        elevation = elevation * Math.pow(islandMask, 3);

        // Store in heightmap
        data[y * width + x] = elevation;
      }
    }

    return data;
  };

  // Create the terrain geometry from heightmap
  const { positions, normals, indices, colors, uvs } = useMemo(() => {
    const heightmap = generateHeightmap(
      resolution,
      resolution,
      smoothing * 100,
      5, // octaves
      0.5, // persistence
      seed
    );

    // Stocker la heightmap pour la réutiliser avec la végétation
    setHeightmapData(heightmap);

    const geometry = {
      positions: new Float32Array(resolution * resolution * 3),
      normals: new Float32Array(resolution * resolution * 3),
      colors: new Float32Array(resolution * resolution * 3),
      uvs: new Float32Array(resolution * resolution * 2),
      indices: [],
    };

    // Create vertices
    for (let z = 0; z < resolution; z++) {
      for (let x = 0; x < resolution; x++) {
        const i = z * resolution + x;

        // Position
        const posIndex = i * 3;
        geometry.positions[posIndex + 0] = (x / (resolution - 1) - 0.5) * size;

        // Get height from heightmap
        const heightValue = heightmap[i];
        geometry.positions[posIndex + 1] = heightValue * height;

        geometry.positions[posIndex + 2] = (z / (resolution - 1) - 0.5) * size;

        // UV coordinates
        const uvIndex = i * 2;
        geometry.uvs[uvIndex + 0] = x / (resolution - 1);
        geometry.uvs[uvIndex + 1] = z / (resolution - 1);

        // Colors - assign based on height thresholds
        const colorIndex = i * 3;
        if (heightValue < beachThreshold) {
          // Beach color
          const c = new THREE.Color(beachColor);
          geometry.colors[colorIndex + 0] = c.r;
          geometry.colors[colorIndex + 1] = c.g;
          geometry.colors[colorIndex + 2] = c.b;
        } else if (heightValue < mountainThreshold) {
          // Grass color
          const c = new THREE.Color(grassColor);
          geometry.colors[colorIndex + 0] = c.r;
          geometry.colors[colorIndex + 1] = c.g;
          geometry.colors[colorIndex + 2] = c.b;
        } else {
          // Mountain color
          const c = new THREE.Color(mountainColor);
          geometry.colors[colorIndex + 0] = c.r;
          geometry.colors[colorIndex + 1] = c.g;
          geometry.colors[colorIndex + 2] = c.b;
        }
      }
    }

    // Create faces (two triangles per grid cell)
    for (let z = 0; z < resolution - 1; z++) {
      for (let x = 0; x < resolution - 1; x++) {
        const i = z * resolution + x;

        // First triangle
        geometry.indices.push(i);
        geometry.indices.push(i + 1);
        geometry.indices.push(i + resolution);

        // Second triangle
        geometry.indices.push(i + 1);
        geometry.indices.push(i + resolution + 1);
        geometry.indices.push(i + resolution);
      }
    }

    // Compute normals
    const positionArray = geometry.positions;
    const normalArray = geometry.normals;
    const indexArray = geometry.indices;

    // Initialize normals to zero
    for (let i = 0; i < normalArray.length; i++) {
      normalArray[i] = 0;
    }

    // Calculate face normals and accumulate them on vertices
    for (let i = 0; i < indexArray.length; i += 3) {
      const i1 = indexArray[i] * 3;
      const i2 = indexArray[i + 1] * 3;
      const i3 = indexArray[i + 2] * 3;

      const v1 = new THREE.Vector3(
        positionArray[i1],
        positionArray[i1 + 1],
        positionArray[i1 + 2]
      );

      const v2 = new THREE.Vector3(
        positionArray[i2],
        positionArray[i2 + 1],
        positionArray[i2 + 2]
      );

      const v3 = new THREE.Vector3(
        positionArray[i3],
        positionArray[i3 + 1],
        positionArray[i3 + 2]
      );

      // Calculate face normal
      const edge1 = new THREE.Vector3().subVectors(v2, v1);
      const edge2 = new THREE.Vector3().subVectors(v3, v1);
      const normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();

      // Add to each vertex
      normalArray[i1] += normal.x;
      normalArray[i1 + 1] += normal.y;
      normalArray[i1 + 2] += normal.z;

      normalArray[i2] += normal.x;
      normalArray[i2 + 1] += normal.y;
      normalArray[i2 + 2] += normal.z;

      normalArray[i3] += normal.x;
      normalArray[i3 + 1] += normal.y;
      normalArray[i3 + 2] += normal.z;
    }

    // Normalize vertex normals
    for (let i = 0; i < normalArray.length; i += 3) {
      const nx = normalArray[i];
      const ny = normalArray[i + 1];
      const nz = normalArray[i + 2];

      const length = Math.sqrt(nx * nx + ny * ny + nz * nz);

      if (length > 0) {
        normalArray[i] = nx / length;
        normalArray[i + 1] = ny / length;
        normalArray[i + 2] = nz / length;
      }
    }

    return geometry;
  }, [
    resolution,
    size,
    height,
    smoothing,
    seed,
    beachThreshold,
    mountainThreshold,
    beachColor,
    grassColor,
    mountainColor,
  ]);

  // Create a buffer geometry from our calculated data
  const bufferGeometry = useMemo(() => {
    const geometry = new THREE.BufferGeometry();

    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

    geometry.setAttribute("normal", new THREE.BufferAttribute(normals, 3));

    geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

    geometry.setAttribute("uv", new THREE.BufferAttribute(uvs, 2));

    geometry.setIndex(indices);

    return geometry;
  }, [positions, normals, colors, uvs, indices]);

  return (
    <group {...props}>
      <RigidBody type="fixed" colliders="trimesh">
        <mesh ref={meshRef} geometry={bufferGeometry} castShadow receiveShadow>
          <meshStandardMaterial
            vertexColors
            roughness={0.8}
            metalness={0.1}
            side={THREE.DoubleSide}
          />
        </mesh>
      </RigidBody>

      {/* Végétation */}
      {enableVegetation && heightmapData && (
        <Vegetation
          heightmap={heightmapData}
          size={size}
          resolution={resolution}
          waterLevel={0} // On utilise 0 comme niveau de l'eau puisqu'il n'y a plus d'eau
          height={height}
          count={vegetationDensity}
          seed={seed}
        />
      )}
    </group>
  );
};
</file>

<file path="src/components/Vegetation.jsx">
import React, { useMemo, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import * as THREE from "three";
import { createNoise2D } from "simplex-noise";
import alea from "alea";

// Composant pour générer des éléments de végétation
export function Vegetation({
  heightmap,
  size,
  resolution,
  waterLevel,
  height,
  count = 50,
  seed = 123,
}) {
  const palmRef = useRef();

  // Chargement des modèles (vous devrez fournir ces modèles)
  // Note: Si vous n'avez pas ces modèles, vous pourriez utiliser des primitives simples comme des cônes et des cylindres
  const palm = useGLTF("/models/palm.glb", true);
  const rock = useGLTF("/models/rock.glb", true);

  // Utiliser une fonction pour positionner la végétation selon la heightmap
  const vegetationInstances = useMemo(() => {
    // Si nous n'avons pas de heightmap, retourner un tableau vide
    if (!heightmap) return [];

    // Créer un générateur de nombres pseudo-aléatoires avec une graine
    const noise2D = createNoise2D(alea(seed));
    const instances = [];

    // Nombre d'essais pour placer la végétation
    const maxAttempts = count * 3;

    // Créer la végétation
    for (let i = 0; i < maxAttempts && instances.length < count; i++) {
      // Position aléatoire sur la grille
      const gridX = Math.floor(Math.random() * (resolution - 1));
      const gridZ = Math.floor(Math.random() * (resolution - 1));

      // Convertir en coordonnées 3D
      const x = (gridX / (resolution - 1) - 0.5) * size;
      const z = (gridZ / (resolution - 1) - 0.5) * size;

      // Obtenir la hauteur à cette position
      const index = gridZ * resolution + gridX;
      const y = heightmap[index] * height;

      // Ne placer la végétation que sur la terre (pas sous l'eau)
      if (y <= waterLevel * height) continue;

      // Utiliser un bruit pour déterminer le type de végétation
      const noiseValue = noise2D(x * 0.05, z * 0.05);

      // Distance par rapport au centre pour favoriser les palmiers sur les bords
      const distance = Math.sqrt(x * x + z * z) / (size * 0.5);
      const distanceFactor = Math.min(1, Math.max(0, (distance - 0.6) * 2.5));

      // Déterminer le type de végétation à placer
      let type, scale, rotation;

      if (
        noiseValue > 0.7 &&
        distanceFactor > 0.7 &&
        y < waterLevel * height + 3
      ) {
        // Palmier sur les bords près de l'eau
        type = "palm";
        scale = 0.2 + Math.random() * 0.3;
        rotation = Math.random() * Math.PI * 2;
      } else if (noiseValue < -0.5) {
        // Rocher
        type = "rock";
        scale = 0.1 + Math.random() * 0.3;
        rotation = Math.random() * Math.PI * 2;
      } else {
        // Pas de végétation ici
        continue;
      }

      // Éviter les superpositions en vérifiant la distance avec les instances existantes
      let tooClose = false;
      for (const instance of instances) {
        const dx = x - instance.position[0];
        const dz = z - instance.position[2];
        const minDistance = type === "palm" ? 5 : 3;

        if (dx * dx + dz * dz < minDistance * minDistance) {
          tooClose = true;
          break;
        }
      }

      if (!tooClose) {
        instances.push({
          type,
          position: [x, y, z],
          scale: [scale, scale, scale],
          rotation: [0, rotation, 0],
        });
      }
    }

    return instances;
  }, [heightmap, size, resolution, waterLevel, height, count, seed]);

  // Rendu des instances de végétation
  const vegetationElements = useMemo(() => {
    return vegetationInstances.map((instance, index) => {
      // Sélectionner le bon modèle
      const model =
        instance.type === "palm" ? palm.scene.clone() : rock.scene.clone();

      return (
        <primitive
          key={index}
          object={model}
          position={instance.position}
          scale={instance.scale}
          rotation={instance.rotation}
          castShadow
        />
      );
    });
  }, [vegetationInstances, palm, rock]);

  // Fallback si les modèles ne sont pas disponibles
  const fallbackElements = useMemo(() => {
    return vegetationInstances.map((instance, index) => {
      if (instance.type === "palm") {
        return (
          <group
            key={index}
            position={instance.position}
            rotation={instance.rotation}
            scale={instance.scale}
          >
            {/* Tronc */}
            <mesh castShadow>
              <cylinderGeometry args={[0.2, 0.4, 4, 8]} />
              <meshStandardMaterial color="#8B4513" roughness={0.8} />
            </mesh>

            {/* Feuilles */}
            <group position={[0, 4, 0]}>
              {[...Array(6)].map((_, i) => (
                <mesh
                  key={i}
                  castShadow
                  rotation={[0.3, (i / 6) * Math.PI * 2, 0]}
                >
                  <coneGeometry args={[2, 3, 4, 1, false, Math.PI / 6]} />
                  <meshStandardMaterial
                    color="#228B22"
                    roughness={0.7}
                    side={THREE.DoubleSide}
                  />
                </mesh>
              ))}
            </group>
          </group>
        );
      } else {
        // Rocher
        return (
          <mesh
            key={index}
            position={instance.position}
            rotation={instance.rotation}
            scale={instance.scale}
            castShadow
          >
            <dodecahedronGeometry args={[1, 0]} />
            <meshStandardMaterial color="#808080" roughness={0.9} />
          </mesh>
        );
      }
    });
  }, [vegetationInstances]);

  return (
    <group>
      {palm.scene && rock.scene ? vegetationElements : fallbackElements}
    </group>
  );
}

// Nous utilisons ces lignes uniquement si vous avez les modèles
useGLTF.preload("/models/palm.glb");
useGLTF.preload("/models/rock.glb");
</file>

<file path="src/index.css">
#root {
  width: 100vw;
  height: 100vh;
}

body {
  margin: 0;
}
</file>

<file path="src/main.jsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
</file>

<file path="vite.config.js">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
})
</file>

</files>
